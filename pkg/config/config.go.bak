package config

import (
	"os"
	"strings"

	"github.com/sirupsen/logrus"
	"github.com/spf13/pflag"
	"github.com/spf13/viper"
)

const (
	// LogConfigOnInitKey is the key name for logging the config on service start
	LogConfigOnInitKey = "log_config_on_init"
	// LogLevelKey is the key name for setting the log level
	LogLevelKey = "log_level"
	// JSONLogFmtKey is the key name to turn on JSON logging
	JSONLogFmtKey  = "json_log_fmt"
	configFileName = "config.yml"
)

type errRequiredConfigMissing struct {
	name string
}

func (e *errRequiredConfigMissing) Error() string {
	return "missing value for config var " + e.name
}

var (
	args        = os.Args[1:]
	serviceName = ""
	version     = "0.0.0"
)

// SetServiceName sets the service name
func SetServiceName(s string) {
	serviceName = s
}

// ServiceName returns the service name
func ServiceName() string {
	return serviceName
}

// SetVersion sets the version
func SetVersion(v string) {
	version = v
}

// Version returns the version
func Version() string {
	return version
}

// SetArgs overrides the os args
func SetArgs(a ...string) {
	args = a
}

type flagVal struct {
	v *string
}

func (v *flagVal) String() string {
	if v.v != nil {
		return *v.v
	}
	return ""
}

func (v *flagVal) Set(val string) error {
	v.v = &val
	return nil
}

func (*flagVal) Type() string {
	return "string"
}

// Var describes a config variable
type Var struct {
	Name     string
	Default  interface{}
	Required bool
	Private  bool
	Flag     *pflag.Flag
}

// Config is the interface which
type Config interface {
	AddVars(...Var)
	Init() error
	Validate() error
}

type config struct {
	prefix  string
	vars    []Var
	flagSet *pflag.FlagSet
}

var defaultVars = []Var{
	{
		Name:    LogConfigOnInitKey,
		Default: true,
	}, {
		Name:    LogLevelKey,
		Default: "info",
	}, {
		Name:    JSONLogFmtKey,
		Default: false,
	},
}

// New returns a pointer to a new config
func New(prefix string, variables ...[]Var) Config {
	c := &config{
		prefix: prefix,
	}
	c.AddVars(defaultVars...)
	for _, v := range variables {
		c.AddVars(v...)
	}
	return c
}

func (c *config) AddVars(vars ...Var) {
	c.vars = append(c.vars, vars...)
}

func (c *config) Init() error {
	logrus.Debug("Setting env prefix: ", c.prefix)
	viper.SetEnvPrefix(c.prefix)
	for _, v := range c.vars {
		logrus.Debug("Binding env var: ", v.Name)
		if err := viper.BindEnv(v.Name); err != nil {
			logrus.Errorf("Error binding env var '%s': %s", v.Name, err)
			return err
		}
		if v.Default != nil {
			logrus.Debugf("Setting default for env var '%s': %+v", v.Name, v.Default)
			viper.SetDefault(v.Name, v.Default)
		}
	}

	var configFilePath string
	c.flagSet = pflag.NewFlagSet(os.Args[0], pflag.ExitOnError)
	c.flagSet.StringVarP(&configFilePath, "config", "c", "", "Path to config file")
	for _, v := range c.vars {
		if v.Flag != nil {
			if v.Flag.Value == nil {
				v.Flag.Value = &flagVal{}
			}
			c.flagSet.AddFlag(v.Flag)
			logrus.Debugf("Binding var '%s' to flag: %+v", v.Name, v.Flag)
			if err := viper.BindPFlag(v.Name, v.Flag); err != nil {
				logrus.Errorf("Error binding var '%s' to flag: %+v", v.Name, v.Flag)
				return err
			}
		}
	}
	if err := c.flagSet.Parse(args); err != nil {
		logrus.Error("Error parsing flags: ", err)
		return err
	}

	if configFilePath == "" {
		configFilePath = "./"
	}

	if err := readInFiles(configFilePath); err != nil {
		return err
	}

	if viper.GetBool(JSONLogFmtKey) {
		logrus.SetFormatter(&logrus.JSONFormatter{})
	}

	logrus.SetLevel(logLevel())

	if viper.GetBool(LogConfigOnInitKey) {
		c.log()
	}

	return nil
}

func readInFiles(configFilePath string) error {
	viper.SetConfigFile(configFilePath + "/" + configFileName)
	if err := viper.ReadInConfig(); err != nil {
		return err
	}
	files, err := os.ReadDir(configFilePath)
	if err != nil {
		return err
	}
	if len(files) > 1 {
		for _, f := range files {
			if strings.HasSuffix(f.Name(), "."+configFileName) {
				viper.SetConfigFile(configFilePath + "/" + f.Name())
				err = viper.MergeInConfig()
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (c *config) Validate() error {
	for _, v := range c.vars {
		if v.Required {
			if viper.Get(v.Name) == nil {
				return &errRequiredConfigMissing{v.Name}
			}
		}
	}
	return nil
}

func logLevel() logrus.Level {
	lev := viper.GetString(LogLevelKey)
	if lev != "" {
		logLevel, err := logrus.ParseLevel(lev)
		if err != nil {
			panic(err)
		}
		return logLevel
	}
	return logrus.InfoLevel
}

func (c *config) log() {
	fields := make(logrus.Fields, len(c.vars))
	for _, v := range c.vars {
		if value := viper.Get(v.Name); value != nil {
			if v.Private {
				fields[v.Name] = "****"
			} else {
				fields[v.Name] = value
			}
		}
	}
	logrus.WithFields(fields).Info("service config")
}
