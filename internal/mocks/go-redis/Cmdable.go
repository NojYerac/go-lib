// Code generated by mockery v2.40.1. DO NOT EDIT.

package mocks

import (
	redis "github.com/go-redis/redis"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// Cmdable is an autogenerated mock type for the Cmdable type
type Cmdable struct {
	mock.Mock
}

// Append provides a mock function with given fields: key, value
func (_m *Cmdable) Append(key string, value string) *redis.IntCmd {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for Append")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.IntCmd); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BLPop provides a mock function with given fields: timeout, keys
func (_m *Cmdable) BLPop(timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BLPop")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(time.Duration, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// BRPop provides a mock function with given fields: timeout, keys
func (_m *Cmdable) BRPop(timeout time.Duration, keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BRPop")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(time.Duration, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// BRPopLPush provides a mock function with given fields: source, destination, timeout
func (_m *Cmdable) BRPopLPush(source string, destination string, timeout time.Duration) *redis.StringCmd {
	ret := _m.Called(source, destination, timeout)

	if len(ret) == 0 {
		panic("no return value specified for BRPopLPush")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, string, time.Duration) *redis.StringCmd); ok {
		r0 = rf(source, destination, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// BZPopMax provides a mock function with given fields: timeout, keys
func (_m *Cmdable) BZPopMax(timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZPopMax")
	}

	var r0 *redis.ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(time.Duration, ...string) *redis.ZWithKeyCmd); ok {
		r0 = rf(timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZWithKeyCmd)
		}
	}

	return r0
}

// BZPopMin provides a mock function with given fields: timeout, keys
func (_m *Cmdable) BZPopMin(timeout time.Duration, keys ...string) *redis.ZWithKeyCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, timeout)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BZPopMin")
	}

	var r0 *redis.ZWithKeyCmd
	if rf, ok := ret.Get(0).(func(time.Duration, ...string) *redis.ZWithKeyCmd); ok {
		r0 = rf(timeout, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZWithKeyCmd)
		}
	}

	return r0
}

// BgRewriteAOF provides a mock function with given fields:
func (_m *Cmdable) BgRewriteAOF() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BgRewriteAOF")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BgSave provides a mock function with given fields:
func (_m *Cmdable) BgSave() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for BgSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// BitCount provides a mock function with given fields: key, bitCount
func (_m *Cmdable) BitCount(key string, bitCount *redis.BitCount) *redis.IntCmd {
	ret := _m.Called(key, bitCount)

	if len(ret) == 0 {
		panic("no return value specified for BitCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, *redis.BitCount) *redis.IntCmd); ok {
		r0 = rf(key, bitCount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpAnd provides a mock function with given fields: destKey, keys
func (_m *Cmdable) BitOpAnd(destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpAnd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpNot provides a mock function with given fields: destKey, key
func (_m *Cmdable) BitOpNot(destKey string, key string) *redis.IntCmd {
	ret := _m.Called(destKey, key)

	if len(ret) == 0 {
		panic("no return value specified for BitOpNot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.IntCmd); ok {
		r0 = rf(destKey, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpOr provides a mock function with given fields: destKey, keys
func (_m *Cmdable) BitOpOr(destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpOr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitOpXor provides a mock function with given fields: destKey, keys
func (_m *Cmdable) BitOpXor(destKey string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destKey)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitOpXor")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destKey, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// BitPos provides a mock function with given fields: key, bit, pos
func (_m *Cmdable) BitPos(key string, bit int64, pos ...int64) *redis.IntCmd {
	_va := make([]interface{}, len(pos))
	for _i := range pos {
		_va[_i] = pos[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key, bit)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BitPos")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64, ...int64) *redis.IntCmd); ok {
		r0 = rf(key, bit, pos...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientGetName provides a mock function with given fields:
func (_m *Cmdable) ClientGetName() *redis.StringCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClientGetName")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func() *redis.StringCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClientID provides a mock function with given fields:
func (_m *Cmdable) ClientID() *redis.IntCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClientID")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func() *redis.IntCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientKill provides a mock function with given fields: ipPort
func (_m *Cmdable) ClientKill(ipPort string) *redis.StatusCmd {
	ret := _m.Called(ipPort)

	if len(ret) == 0 {
		panic("no return value specified for ClientKill")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StatusCmd); ok {
		r0 = rf(ipPort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClientKillByFilter provides a mock function with given fields: keys
func (_m *Cmdable) ClientKillByFilter(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClientKillByFilter")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClientList provides a mock function with given fields:
func (_m *Cmdable) ClientList() *redis.StringCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClientList")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func() *redis.StringCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClientPause provides a mock function with given fields: dur
func (_m *Cmdable) ClientPause(dur time.Duration) *redis.BoolCmd {
	ret := _m.Called(dur)

	if len(ret) == 0 {
		panic("no return value specified for ClientPause")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(time.Duration) *redis.BoolCmd); ok {
		r0 = rf(dur)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ClusterAddSlots provides a mock function with given fields: slots
func (_m *Cmdable) ClusterAddSlots(slots ...int) *redis.StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAddSlots")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(...int) *redis.StatusCmd); ok {
		r0 = rf(slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterAddSlotsRange provides a mock function with given fields: min, max
func (_m *Cmdable) ClusterAddSlotsRange(min int, max int) *redis.StatusCmd {
	ret := _m.Called(min, max)

	if len(ret) == 0 {
		panic("no return value specified for ClusterAddSlotsRange")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(int, int) *redis.StatusCmd); ok {
		r0 = rf(min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterCountFailureReports provides a mock function with given fields: nodeID
func (_m *Cmdable) ClusterCountFailureReports(nodeID string) *redis.IntCmd {
	ret := _m.Called(nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCountFailureReports")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterCountKeysInSlot provides a mock function with given fields: slot
func (_m *Cmdable) ClusterCountKeysInSlot(slot int) *redis.IntCmd {
	ret := _m.Called(slot)

	if len(ret) == 0 {
		panic("no return value specified for ClusterCountKeysInSlot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(int) *redis.IntCmd); ok {
		r0 = rf(slot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterDelSlots provides a mock function with given fields: slots
func (_m *Cmdable) ClusterDelSlots(slots ...int) *redis.StatusCmd {
	_va := make([]interface{}, len(slots))
	for _i := range slots {
		_va[_i] = slots[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ClusterDelSlots")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(...int) *redis.StatusCmd); ok {
		r0 = rf(slots...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterDelSlotsRange provides a mock function with given fields: min, max
func (_m *Cmdable) ClusterDelSlotsRange(min int, max int) *redis.StatusCmd {
	ret := _m.Called(min, max)

	if len(ret) == 0 {
		panic("no return value specified for ClusterDelSlotsRange")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(int, int) *redis.StatusCmd); ok {
		r0 = rf(min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterFailover provides a mock function with given fields:
func (_m *Cmdable) ClusterFailover() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClusterFailover")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterForget provides a mock function with given fields: nodeID
func (_m *Cmdable) ClusterForget(nodeID string) *redis.StatusCmd {
	ret := _m.Called(nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterForget")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StatusCmd); ok {
		r0 = rf(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterGetKeysInSlot provides a mock function with given fields: slot, count
func (_m *Cmdable) ClusterGetKeysInSlot(slot int, count int) *redis.StringSliceCmd {
	ret := _m.Called(slot, count)

	if len(ret) == 0 {
		panic("no return value specified for ClusterGetKeysInSlot")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(int, int) *redis.StringSliceCmd); ok {
		r0 = rf(slot, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ClusterInfo provides a mock function with given fields:
func (_m *Cmdable) ClusterInfo() *redis.StringCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClusterInfo")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func() *redis.StringCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClusterKeySlot provides a mock function with given fields: key
func (_m *Cmdable) ClusterKeySlot(key string) *redis.IntCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ClusterKeySlot")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ClusterMeet provides a mock function with given fields: host, port
func (_m *Cmdable) ClusterMeet(host string, port string) *redis.StatusCmd {
	ret := _m.Called(host, port)

	if len(ret) == 0 {
		panic("no return value specified for ClusterMeet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StatusCmd); ok {
		r0 = rf(host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterNodes provides a mock function with given fields:
func (_m *Cmdable) ClusterNodes() *redis.StringCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClusterNodes")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func() *redis.StringCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ClusterReplicate provides a mock function with given fields: nodeID
func (_m *Cmdable) ClusterReplicate(nodeID string) *redis.StatusCmd {
	ret := _m.Called(nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterReplicate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StatusCmd); ok {
		r0 = rf(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterResetHard provides a mock function with given fields:
func (_m *Cmdable) ClusterResetHard() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClusterResetHard")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterResetSoft provides a mock function with given fields:
func (_m *Cmdable) ClusterResetSoft() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClusterResetSoft")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterSaveConfig provides a mock function with given fields:
func (_m *Cmdable) ClusterSaveConfig() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClusterSaveConfig")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ClusterSlaves provides a mock function with given fields: nodeID
func (_m *Cmdable) ClusterSlaves(nodeID string) *redis.StringSliceCmd {
	ret := _m.Called(nodeID)

	if len(ret) == 0 {
		panic("no return value specified for ClusterSlaves")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ClusterSlots provides a mock function with given fields:
func (_m *Cmdable) ClusterSlots() *redis.ClusterSlotsCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ClusterSlots")
	}

	var r0 *redis.ClusterSlotsCmd
	if rf, ok := ret.Get(0).(func() *redis.ClusterSlotsCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ClusterSlotsCmd)
		}
	}

	return r0
}

// Command provides a mock function with given fields:
func (_m *Cmdable) Command() *redis.CommandsInfoCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Command")
	}

	var r0 *redis.CommandsInfoCmd
	if rf, ok := ret.Get(0).(func() *redis.CommandsInfoCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.CommandsInfoCmd)
		}
	}

	return r0
}

// ConfigGet provides a mock function with given fields: parameter
func (_m *Cmdable) ConfigGet(parameter string) *redis.SliceCmd {
	ret := _m.Called(parameter)

	if len(ret) == 0 {
		panic("no return value specified for ConfigGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.SliceCmd); ok {
		r0 = rf(parameter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// ConfigResetStat provides a mock function with given fields:
func (_m *Cmdable) ConfigResetStat() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ConfigResetStat")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ConfigRewrite provides a mock function with given fields:
func (_m *Cmdable) ConfigRewrite() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ConfigRewrite")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ConfigSet provides a mock function with given fields: parameter, value
func (_m *Cmdable) ConfigSet(parameter string, value string) *redis.StatusCmd {
	ret := _m.Called(parameter, value)

	if len(ret) == 0 {
		panic("no return value specified for ConfigSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StatusCmd); ok {
		r0 = rf(parameter, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// DBSize provides a mock function with given fields:
func (_m *Cmdable) DBSize() *redis.IntCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DBSize")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func() *redis.IntCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// DebugObject provides a mock function with given fields: key
func (_m *Cmdable) DebugObject(key string) *redis.StringCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for DebugObject")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Decr provides a mock function with given fields: key
func (_m *Cmdable) Decr(key string) *redis.IntCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Decr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// DecrBy provides a mock function with given fields: key, decrement
func (_m *Cmdable) DecrBy(key string, decrement int64) *redis.IntCmd {
	ret := _m.Called(key, decrement)

	if len(ret) == 0 {
		panic("no return value specified for DecrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.IntCmd); ok {
		r0 = rf(key, decrement)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Del provides a mock function with given fields: keys
func (_m *Cmdable) Del(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Del")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Dump provides a mock function with given fields: key
func (_m *Cmdable) Dump(key string) *redis.StringCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Dump")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Echo provides a mock function with given fields: message
func (_m *Cmdable) Echo(message interface{}) *redis.StringCmd {
	ret := _m.Called(message)

	if len(ret) == 0 {
		panic("no return value specified for Echo")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(interface{}) *redis.StringCmd); ok {
		r0 = rf(message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Eval provides a mock function with given fields: script, keys, args
func (_m *Cmdable) Eval(script string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, script, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Eval")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(script, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// EvalSha provides a mock function with given fields: sha1, keys, args
func (_m *Cmdable) EvalSha(sha1 string, keys []string, args ...interface{}) *redis.Cmd {
	var _ca []interface{}
	_ca = append(_ca, sha1, keys)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EvalSha")
	}

	var r0 *redis.Cmd
	if rf, ok := ret.Get(0).(func(string, []string, ...interface{}) *redis.Cmd); ok {
		r0 = rf(sha1, keys, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.Cmd)
		}
	}

	return r0
}

// Exists provides a mock function with given fields: keys
func (_m *Cmdable) Exists(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Expire provides a mock function with given fields: key, expiration
func (_m *Cmdable) Expire(key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Expire")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ExpireAt provides a mock function with given fields: key, tm
func (_m *Cmdable) ExpireAt(key string, tm time.Time) *redis.BoolCmd {
	ret := _m.Called(key, tm)

	if len(ret) == 0 {
		panic("no return value specified for ExpireAt")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, time.Time) *redis.BoolCmd); ok {
		r0 = rf(key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// FlushAll provides a mock function with given fields:
func (_m *Cmdable) FlushAll() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for FlushAll")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushAllAsync provides a mock function with given fields:
func (_m *Cmdable) FlushAllAsync() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for FlushAllAsync")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushDB provides a mock function with given fields:
func (_m *Cmdable) FlushDB() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for FlushDB")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// FlushDBAsync provides a mock function with given fields:
func (_m *Cmdable) FlushDBAsync() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for FlushDBAsync")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// GeoAdd provides a mock function with given fields: key, geoLocation
func (_m *Cmdable) GeoAdd(key string, geoLocation ...*redis.GeoLocation) *redis.IntCmd {
	_va := make([]interface{}, len(geoLocation))
	for _i := range geoLocation {
		_va[_i] = geoLocation[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...*redis.GeoLocation) *redis.IntCmd); ok {
		r0 = rf(key, geoLocation...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GeoDist provides a mock function with given fields: key, member1, member2, unit
func (_m *Cmdable) GeoDist(key string, member1 string, member2 string, unit string) *redis.FloatCmd {
	ret := _m.Called(key, member1, member2, unit)

	if len(ret) == 0 {
		panic("no return value specified for GeoDist")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, string, string, string) *redis.FloatCmd); ok {
		r0 = rf(key, member1, member2, unit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// GeoHash provides a mock function with given fields: key, members
func (_m *Cmdable) GeoHash(key string, members ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoHash")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.StringSliceCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// GeoPos provides a mock function with given fields: key, members
func (_m *Cmdable) GeoPos(key string, members ...string) *redis.GeoPosCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GeoPos")
	}

	var r0 *redis.GeoPosCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.GeoPosCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoPosCmd)
		}
	}

	return r0
}

// GeoRadius provides a mock function with given fields: key, longitude, latitude, query
func (_m *Cmdable) GeoRadius(key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadius")
	}

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(string, float64, float64, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// GeoRadiusByMember provides a mock function with given fields: key, member, query
func (_m *Cmdable) GeoRadiusByMember(key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMember")
	}

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(string, string, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// GeoRadiusByMemberRO provides a mock function with given fields: key, member, query
func (_m *Cmdable) GeoRadiusByMemberRO(key string, member string, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(key, member, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusByMemberRO")
	}

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(string, string, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(key, member, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// GeoRadiusRO provides a mock function with given fields: key, longitude, latitude, query
func (_m *Cmdable) GeoRadiusRO(key string, longitude float64, latitude float64, query *redis.GeoRadiusQuery) *redis.GeoLocationCmd {
	ret := _m.Called(key, longitude, latitude, query)

	if len(ret) == 0 {
		panic("no return value specified for GeoRadiusRO")
	}

	var r0 *redis.GeoLocationCmd
	if rf, ok := ret.Get(0).(func(string, float64, float64, *redis.GeoRadiusQuery) *redis.GeoLocationCmd); ok {
		r0 = rf(key, longitude, latitude, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.GeoLocationCmd)
		}
	}

	return r0
}

// Get provides a mock function with given fields: key
func (_m *Cmdable) Get(key string) *redis.StringCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetBit provides a mock function with given fields: key, offset
func (_m *Cmdable) GetBit(key string, offset int64) *redis.IntCmd {
	ret := _m.Called(key, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetBit")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.IntCmd); ok {
		r0 = rf(key, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// GetRange provides a mock function with given fields: key, start, end
func (_m *Cmdable) GetRange(key string, start int64, end int64) *redis.StringCmd {
	ret := _m.Called(key, start, end)

	if len(ret) == 0 {
		panic("no return value specified for GetRange")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.StringCmd); ok {
		r0 = rf(key, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// GetSet provides a mock function with given fields: key, value
func (_m *Cmdable) GetSet(key string, value interface{}) *redis.StringCmd {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for GetSet")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, interface{}) *redis.StringCmd); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// HDel provides a mock function with given fields: key, fields
func (_m *Cmdable) HDel(key string, fields ...string) *redis.IntCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HExists provides a mock function with given fields: key, field
func (_m *Cmdable) HExists(key string, field string) *redis.BoolCmd {
	ret := _m.Called(key, field)

	if len(ret) == 0 {
		panic("no return value specified for HExists")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.BoolCmd); ok {
		r0 = rf(key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HGet provides a mock function with given fields: key, field
func (_m *Cmdable) HGet(key string, field string) *redis.StringCmd {
	ret := _m.Called(key, field)

	if len(ret) == 0 {
		panic("no return value specified for HGet")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StringCmd); ok {
		r0 = rf(key, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// HGetAll provides a mock function with given fields: key
func (_m *Cmdable) HGetAll(key string) *redis.StringStringMapCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for HGetAll")
	}

	var r0 *redis.StringStringMapCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringStringMapCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringStringMapCmd)
		}
	}

	return r0
}

// HIncrBy provides a mock function with given fields: key, field, incr
func (_m *Cmdable) HIncrBy(key string, field string, incr int64) *redis.IntCmd {
	ret := _m.Called(key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, int64) *redis.IntCmd); ok {
		r0 = rf(key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HIncrByFloat provides a mock function with given fields: key, field, incr
func (_m *Cmdable) HIncrByFloat(key string, field string, incr float64) *redis.FloatCmd {
	ret := _m.Called(key, field, incr)

	if len(ret) == 0 {
		panic("no return value specified for HIncrByFloat")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, string, float64) *redis.FloatCmd); ok {
		r0 = rf(key, field, incr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// HKeys provides a mock function with given fields: key
func (_m *Cmdable) HKeys(key string) *redis.StringSliceCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for HKeys")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// HLen provides a mock function with given fields: key
func (_m *Cmdable) HLen(key string) *redis.IntCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for HLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// HMGet provides a mock function with given fields: key, fields
func (_m *Cmdable) HMGet(key string, fields ...string) *redis.SliceCmd {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.SliceCmd); ok {
		r0 = rf(key, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// HMSet provides a mock function with given fields: key, fields
func (_m *Cmdable) HMSet(key string, fields map[string]interface{}) *redis.StatusCmd {
	ret := _m.Called(key, fields)

	if len(ret) == 0 {
		panic("no return value specified for HMSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) *redis.StatusCmd); ok {
		r0 = rf(key, fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// HScan provides a mock function with given fields: key, cursor, match, count
func (_m *Cmdable) HScan(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for HScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// HSet provides a mock function with given fields: key, field, value
func (_m *Cmdable) HSet(key string, field string, value interface{}) *redis.BoolCmd {
	ret := _m.Called(key, field, value)

	if len(ret) == 0 {
		panic("no return value specified for HSet")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(key, field, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HSetNX provides a mock function with given fields: key, field, value
func (_m *Cmdable) HSetNX(key string, field string, value interface{}) *redis.BoolCmd {
	ret := _m.Called(key, field, value)

	if len(ret) == 0 {
		panic("no return value specified for HSetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(key, field, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// HVals provides a mock function with given fields: key
func (_m *Cmdable) HVals(key string) *redis.StringSliceCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for HVals")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// Incr provides a mock function with given fields: key
func (_m *Cmdable) Incr(key string) *redis.IntCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Incr")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// IncrBy provides a mock function with given fields: key, value
func (_m *Cmdable) IncrBy(key string, value int64) *redis.IntCmd {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrBy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.IntCmd); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// IncrByFloat provides a mock function with given fields: key, value
func (_m *Cmdable) IncrByFloat(key string, value float64) *redis.FloatCmd {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for IncrByFloat")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, float64) *redis.FloatCmd); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// Info provides a mock function with given fields: section
func (_m *Cmdable) Info(section ...string) *redis.StringCmd {
	_va := make([]interface{}, len(section))
	for _i := range section {
		_va[_i] = section[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Info")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.StringCmd); ok {
		r0 = rf(section...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Keys provides a mock function with given fields: pattern
func (_m *Cmdable) Keys(pattern string) *redis.StringSliceCmd {
	ret := _m.Called(pattern)

	if len(ret) == 0 {
		panic("no return value specified for Keys")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// LIndex provides a mock function with given fields: key, index
func (_m *Cmdable) LIndex(key string, index int64) *redis.StringCmd {
	ret := _m.Called(key, index)

	if len(ret) == 0 {
		panic("no return value specified for LIndex")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.StringCmd); ok {
		r0 = rf(key, index)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// LInsert provides a mock function with given fields: key, op, pivot, value
func (_m *Cmdable) LInsert(key string, op string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(key, op, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsert")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(key, op, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LInsertAfter provides a mock function with given fields: key, pivot, value
func (_m *Cmdable) LInsertAfter(key string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertAfter")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LInsertBefore provides a mock function with given fields: key, pivot, value
func (_m *Cmdable) LInsertBefore(key string, pivot interface{}, value interface{}) *redis.IntCmd {
	ret := _m.Called(key, pivot, value)

	if len(ret) == 0 {
		panic("no return value specified for LInsertBefore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) *redis.IntCmd); ok {
		r0 = rf(key, pivot, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LLen provides a mock function with given fields: key
func (_m *Cmdable) LLen(key string) *redis.IntCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for LLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LPop provides a mock function with given fields: key
func (_m *Cmdable) LPop(key string) *redis.StringCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for LPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// LPush provides a mock function with given fields: key, values
func (_m *Cmdable) LPush(key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LPush")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LPushX provides a mock function with given fields: key, value
func (_m *Cmdable) LPushX(key string, value interface{}) *redis.IntCmd {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for LPushX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, interface{}) *redis.IntCmd); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LRange provides a mock function with given fields: key, start, stop
func (_m *Cmdable) LRange(key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// LRem provides a mock function with given fields: key, count, value
func (_m *Cmdable) LRem(key string, count int64, value interface{}) *redis.IntCmd {
	ret := _m.Called(key, count, value)

	if len(ret) == 0 {
		panic("no return value specified for LRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64, interface{}) *redis.IntCmd); ok {
		r0 = rf(key, count, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// LSet provides a mock function with given fields: key, index, value
func (_m *Cmdable) LSet(key string, index int64, value interface{}) *redis.StatusCmd {
	ret := _m.Called(key, index, value)

	if len(ret) == 0 {
		panic("no return value specified for LSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, int64, interface{}) *redis.StatusCmd); ok {
		r0 = rf(key, index, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// LTrim provides a mock function with given fields: key, start, stop
func (_m *Cmdable) LTrim(key string, start int64, stop int64) *redis.StatusCmd {
	ret := _m.Called(key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for LTrim")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.StatusCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// LastSave provides a mock function with given fields:
func (_m *Cmdable) LastSave() *redis.IntCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LastSave")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func() *redis.IntCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// MGet provides a mock function with given fields: keys
func (_m *Cmdable) MGet(keys ...string) *redis.SliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MGet")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.SliceCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// MSet provides a mock function with given fields: pairs
func (_m *Cmdable) MSet(pairs ...interface{}) *redis.StatusCmd {
	var _ca []interface{}
	_ca = append(_ca, pairs...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSet")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(...interface{}) *redis.StatusCmd); ok {
		r0 = rf(pairs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// MSetNX provides a mock function with given fields: pairs
func (_m *Cmdable) MSetNX(pairs ...interface{}) *redis.BoolCmd {
	var _ca []interface{}
	_ca = append(_ca, pairs...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MSetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(...interface{}) *redis.BoolCmd); ok {
		r0 = rf(pairs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// MemoryUsage provides a mock function with given fields: key, samples
func (_m *Cmdable) MemoryUsage(key string, samples ...int) *redis.IntCmd {
	_va := make([]interface{}, len(samples))
	for _i := range samples {
		_va[_i] = samples[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MemoryUsage")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...int) *redis.IntCmd); ok {
		r0 = rf(key, samples...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Migrate provides a mock function with given fields: host, port, key, db, timeout
func (_m *Cmdable) Migrate(host string, port string, key string, db int64, timeout time.Duration) *redis.StatusCmd {
	ret := _m.Called(host, port, key, db, timeout)

	if len(ret) == 0 {
		panic("no return value specified for Migrate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string, string, int64, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(host, port, key, db, timeout)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Move provides a mock function with given fields: key, db
func (_m *Cmdable) Move(key string, db int64) *redis.BoolCmd {
	ret := _m.Called(key, db)

	if len(ret) == 0 {
		panic("no return value specified for Move")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.BoolCmd); ok {
		r0 = rf(key, db)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// ObjectEncoding provides a mock function with given fields: key
func (_m *Cmdable) ObjectEncoding(key string) *redis.StringCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectEncoding")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ObjectIdleTime provides a mock function with given fields: key
func (_m *Cmdable) ObjectIdleTime(key string) *redis.DurationCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectIdleTime")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(string) *redis.DurationCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// ObjectRefCount provides a mock function with given fields: key
func (_m *Cmdable) ObjectRefCount(key string) *redis.IntCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ObjectRefCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PExpire provides a mock function with given fields: key, expiration
func (_m *Cmdable) PExpire(key string, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(key, expiration)

	if len(ret) == 0 {
		panic("no return value specified for PExpire")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(key, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// PExpireAt provides a mock function with given fields: key, tm
func (_m *Cmdable) PExpireAt(key string, tm time.Time) *redis.BoolCmd {
	ret := _m.Called(key, tm)

	if len(ret) == 0 {
		panic("no return value specified for PExpireAt")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, time.Time) *redis.BoolCmd); ok {
		r0 = rf(key, tm)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// PFAdd provides a mock function with given fields: key, els
func (_m *Cmdable) PFAdd(key string, els ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, els...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, els...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PFCount provides a mock function with given fields: keys
func (_m *Cmdable) PFCount(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PFMerge provides a mock function with given fields: dest, keys
func (_m *Cmdable) PFMerge(dest string, keys ...string) *redis.StatusCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, dest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PFMerge")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.StatusCmd); ok {
		r0 = rf(dest, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// PTTL provides a mock function with given fields: key
func (_m *Cmdable) PTTL(key string) *redis.DurationCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for PTTL")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(string) *redis.DurationCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// Persist provides a mock function with given fields: key
func (_m *Cmdable) Persist(key string) *redis.BoolCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Persist")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string) *redis.BoolCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Ping provides a mock function with given fields:
func (_m *Cmdable) Ping() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Pipeline provides a mock function with given fields:
func (_m *Cmdable) Pipeline() redis.Pipeliner {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Pipeline")
	}

	var r0 redis.Pipeliner
	if rf, ok := ret.Get(0).(func() redis.Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redis.Pipeliner)
		}
	}

	return r0
}

// Pipelined provides a mock function with given fields: fn
func (_m *Cmdable) Pipelined(fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	ret := _m.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for Pipelined")
	}

	var r0 []redis.Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(func(redis.Pipeliner) error) ([]redis.Cmder, error)); ok {
		return rf(fn)
	}
	if rf, ok := ret.Get(0).(func(func(redis.Pipeliner) error) []redis.Cmder); ok {
		r0 = rf(fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(func(redis.Pipeliner) error) error); ok {
		r1 = rf(fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PubSubChannels provides a mock function with given fields: pattern
func (_m *Cmdable) PubSubChannels(pattern string) *redis.StringSliceCmd {
	ret := _m.Called(pattern)

	if len(ret) == 0 {
		panic("no return value specified for PubSubChannels")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(pattern)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// PubSubNumPat provides a mock function with given fields:
func (_m *Cmdable) PubSubNumPat() *redis.IntCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumPat")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func() *redis.IntCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// PubSubNumSub provides a mock function with given fields: channels
func (_m *Cmdable) PubSubNumSub(channels ...string) *redis.StringIntMapCmd {
	_va := make([]interface{}, len(channels))
	for _i := range channels {
		_va[_i] = channels[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PubSubNumSub")
	}

	var r0 *redis.StringIntMapCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.StringIntMapCmd); ok {
		r0 = rf(channels...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringIntMapCmd)
		}
	}

	return r0
}

// Publish provides a mock function with given fields: channel, message
func (_m *Cmdable) Publish(channel string, message interface{}) *redis.IntCmd {
	ret := _m.Called(channel, message)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, interface{}) *redis.IntCmd); ok {
		r0 = rf(channel, message)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Quit provides a mock function with given fields:
func (_m *Cmdable) Quit() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Quit")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RPop provides a mock function with given fields: key
func (_m *Cmdable) RPop(key string) *redis.StringCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for RPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// RPopLPush provides a mock function with given fields: source, destination
func (_m *Cmdable) RPopLPush(source string, destination string) *redis.StringCmd {
	ret := _m.Called(source, destination)

	if len(ret) == 0 {
		panic("no return value specified for RPopLPush")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StringCmd); ok {
		r0 = rf(source, destination)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// RPush provides a mock function with given fields: key, values
func (_m *Cmdable) RPush(key string, values ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RPush")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// RPushX provides a mock function with given fields: key, value
func (_m *Cmdable) RPushX(key string, value interface{}) *redis.IntCmd {
	ret := _m.Called(key, value)

	if len(ret) == 0 {
		panic("no return value specified for RPushX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, interface{}) *redis.IntCmd); ok {
		r0 = rf(key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// RandomKey provides a mock function with given fields:
func (_m *Cmdable) RandomKey() *redis.StringCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for RandomKey")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func() *redis.StringCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// ReadOnly provides a mock function with given fields:
func (_m *Cmdable) ReadOnly() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ReadOnly")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ReadWrite provides a mock function with given fields:
func (_m *Cmdable) ReadWrite() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ReadWrite")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Rename provides a mock function with given fields: key, newkey
func (_m *Cmdable) Rename(key string, newkey string) *redis.StatusCmd {
	ret := _m.Called(key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for Rename")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StatusCmd); ok {
		r0 = rf(key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RenameNX provides a mock function with given fields: key, newkey
func (_m *Cmdable) RenameNX(key string, newkey string) *redis.BoolCmd {
	ret := _m.Called(key, newkey)

	if len(ret) == 0 {
		panic("no return value specified for RenameNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.BoolCmd); ok {
		r0 = rf(key, newkey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Restore provides a mock function with given fields: key, ttl, value
func (_m *Cmdable) Restore(key string, ttl time.Duration, value string) *redis.StatusCmd {
	ret := _m.Called(key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for Restore")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, time.Duration, string) *redis.StatusCmd); ok {
		r0 = rf(key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// RestoreReplace provides a mock function with given fields: key, ttl, value
func (_m *Cmdable) RestoreReplace(key string, ttl time.Duration, value string) *redis.StatusCmd {
	ret := _m.Called(key, ttl, value)

	if len(ret) == 0 {
		panic("no return value specified for RestoreReplace")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, time.Duration, string) *redis.StatusCmd); ok {
		r0 = rf(key, ttl, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SAdd provides a mock function with given fields: key, members
func (_m *Cmdable) SAdd(key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SCard provides a mock function with given fields: key
func (_m *Cmdable) SCard(key string) *redis.IntCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for SCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SDiff provides a mock function with given fields: keys
func (_m *Cmdable) SDiff(keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SDiff")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.StringSliceCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SDiffStore provides a mock function with given fields: destination, keys
func (_m *Cmdable) SDiffStore(destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SDiffStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SInter provides a mock function with given fields: keys
func (_m *Cmdable) SInter(keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInter")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.StringSliceCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SInterStore provides a mock function with given fields: destination, keys
func (_m *Cmdable) SInterStore(destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SInterStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SIsMember provides a mock function with given fields: key, member
func (_m *Cmdable) SIsMember(key string, member interface{}) *redis.BoolCmd {
	ret := _m.Called(key, member)

	if len(ret) == 0 {
		panic("no return value specified for SIsMember")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SMembers provides a mock function with given fields: key
func (_m *Cmdable) SMembers(key string) *redis.StringSliceCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for SMembers")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringSliceCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SMembersMap provides a mock function with given fields: key
func (_m *Cmdable) SMembersMap(key string) *redis.StringStructMapCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for SMembersMap")
	}

	var r0 *redis.StringStructMapCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringStructMapCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringStructMapCmd)
		}
	}

	return r0
}

// SMove provides a mock function with given fields: source, destination, member
func (_m *Cmdable) SMove(source string, destination string, member interface{}) *redis.BoolCmd {
	ret := _m.Called(source, destination, member)

	if len(ret) == 0 {
		panic("no return value specified for SMove")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, string, interface{}) *redis.BoolCmd); ok {
		r0 = rf(source, destination, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SPop provides a mock function with given fields: key
func (_m *Cmdable) SPop(key string) *redis.StringCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for SPop")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// SPopN provides a mock function with given fields: key, count
func (_m *Cmdable) SPopN(key string, count int64) *redis.StringSliceCmd {
	ret := _m.Called(key, count)

	if len(ret) == 0 {
		panic("no return value specified for SPopN")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.StringSliceCmd); ok {
		r0 = rf(key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SRandMember provides a mock function with given fields: key
func (_m *Cmdable) SRandMember(key string) *redis.StringCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for SRandMember")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// SRandMemberN provides a mock function with given fields: key, count
func (_m *Cmdable) SRandMemberN(key string, count int64) *redis.StringSliceCmd {
	ret := _m.Called(key, count)

	if len(ret) == 0 {
		panic("no return value specified for SRandMemberN")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.StringSliceCmd); ok {
		r0 = rf(key, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SRem provides a mock function with given fields: key, members
func (_m *Cmdable) SRem(key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SScan provides a mock function with given fields: key, cursor, match, count
func (_m *Cmdable) SScan(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for SScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// SUnion provides a mock function with given fields: keys
func (_m *Cmdable) SUnion(keys ...string) *redis.StringSliceCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SUnion")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.StringSliceCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SUnionStore provides a mock function with given fields: destination, keys
func (_m *Cmdable) SUnionStore(destination string, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destination)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SUnionStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(destination, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// Save provides a mock function with given fields:
func (_m *Cmdable) Save() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Scan provides a mock function with given fields: cursor, match, count
func (_m *Cmdable) Scan(cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for Scan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// ScriptExists provides a mock function with given fields: hashes
func (_m *Cmdable) ScriptExists(hashes ...string) *redis.BoolSliceCmd {
	_va := make([]interface{}, len(hashes))
	for _i := range hashes {
		_va[_i] = hashes[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ScriptExists")
	}

	var r0 *redis.BoolSliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.BoolSliceCmd); ok {
		r0 = rf(hashes...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolSliceCmd)
		}
	}

	return r0
}

// ScriptFlush provides a mock function with given fields:
func (_m *Cmdable) ScriptFlush() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ScriptFlush")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ScriptKill provides a mock function with given fields:
func (_m *Cmdable) ScriptKill() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ScriptKill")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ScriptLoad provides a mock function with given fields: script
func (_m *Cmdable) ScriptLoad(script string) *redis.StringCmd {
	ret := _m.Called(script)

	if len(ret) == 0 {
		panic("no return value specified for ScriptLoad")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StringCmd); ok {
		r0 = rf(script)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// Set provides a mock function with given fields: key, value, expiration
func (_m *Cmdable) Set(key string, value interface{}, expiration time.Duration) *redis.StatusCmd {
	ret := _m.Called(key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) *redis.StatusCmd); ok {
		r0 = rf(key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SetBit provides a mock function with given fields: key, offset, value
func (_m *Cmdable) SetBit(key string, offset int64, value int) *redis.IntCmd {
	ret := _m.Called(key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetBit")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64, int) *redis.IntCmd); ok {
		r0 = rf(key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SetNX provides a mock function with given fields: key, value, expiration
func (_m *Cmdable) SetNX(key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetNX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// SetRange provides a mock function with given fields: key, offset, value
func (_m *Cmdable) SetRange(key string, offset int64, value string) *redis.IntCmd {
	ret := _m.Called(key, offset, value)

	if len(ret) == 0 {
		panic("no return value specified for SetRange")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64, string) *redis.IntCmd); ok {
		r0 = rf(key, offset, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// SetXX provides a mock function with given fields: key, value, expiration
func (_m *Cmdable) SetXX(key string, value interface{}, expiration time.Duration) *redis.BoolCmd {
	ret := _m.Called(key, value, expiration)

	if len(ret) == 0 {
		panic("no return value specified for SetXX")
	}

	var r0 *redis.BoolCmd
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Duration) *redis.BoolCmd); ok {
		r0 = rf(key, value, expiration)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.BoolCmd)
		}
	}

	return r0
}

// Shutdown provides a mock function with given fields:
func (_m *Cmdable) Shutdown() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Shutdown")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ShutdownNoSave provides a mock function with given fields:
func (_m *Cmdable) ShutdownNoSave() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ShutdownNoSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// ShutdownSave provides a mock function with given fields:
func (_m *Cmdable) ShutdownSave() *redis.StatusCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for ShutdownSave")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func() *redis.StatusCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// SlaveOf provides a mock function with given fields: host, port
func (_m *Cmdable) SlaveOf(host string, port string) *redis.StatusCmd {
	ret := _m.Called(host, port)

	if len(ret) == 0 {
		panic("no return value specified for SlaveOf")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.StatusCmd); ok {
		r0 = rf(host, port)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Sort provides a mock function with given fields: key, sort
func (_m *Cmdable) Sort(key string, sort *redis.Sort) *redis.StringSliceCmd {
	ret := _m.Called(key, sort)

	if len(ret) == 0 {
		panic("no return value specified for Sort")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, *redis.Sort) *redis.StringSliceCmd); ok {
		r0 = rf(key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// SortInterfaces provides a mock function with given fields: key, sort
func (_m *Cmdable) SortInterfaces(key string, sort *redis.Sort) *redis.SliceCmd {
	ret := _m.Called(key, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortInterfaces")
	}

	var r0 *redis.SliceCmd
	if rf, ok := ret.Get(0).(func(string, *redis.Sort) *redis.SliceCmd); ok {
		r0 = rf(key, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.SliceCmd)
		}
	}

	return r0
}

// SortStore provides a mock function with given fields: key, store, sort
func (_m *Cmdable) SortStore(key string, store string, sort *redis.Sort) *redis.IntCmd {
	ret := _m.Called(key, store, sort)

	if len(ret) == 0 {
		panic("no return value specified for SortStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, *redis.Sort) *redis.IntCmd); ok {
		r0 = rf(key, store, sort)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// StrLen provides a mock function with given fields: key
func (_m *Cmdable) StrLen(key string) *redis.IntCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for StrLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TTL provides a mock function with given fields: key
func (_m *Cmdable) TTL(key string) *redis.DurationCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for TTL")
	}

	var r0 *redis.DurationCmd
	if rf, ok := ret.Get(0).(func(string) *redis.DurationCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.DurationCmd)
		}
	}

	return r0
}

// Time provides a mock function with given fields:
func (_m *Cmdable) Time() *redis.TimeCmd {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Time")
	}

	var r0 *redis.TimeCmd
	if rf, ok := ret.Get(0).(func() *redis.TimeCmd); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.TimeCmd)
		}
	}

	return r0
}

// Touch provides a mock function with given fields: keys
func (_m *Cmdable) Touch(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Touch")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// TxPipeline provides a mock function with given fields:
func (_m *Cmdable) TxPipeline() redis.Pipeliner {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for TxPipeline")
	}

	var r0 redis.Pipeliner
	if rf, ok := ret.Get(0).(func() redis.Pipeliner); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(redis.Pipeliner)
		}
	}

	return r0
}

// TxPipelined provides a mock function with given fields: fn
func (_m *Cmdable) TxPipelined(fn func(redis.Pipeliner) error) ([]redis.Cmder, error) {
	ret := _m.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for TxPipelined")
	}

	var r0 []redis.Cmder
	var r1 error
	if rf, ok := ret.Get(0).(func(func(redis.Pipeliner) error) ([]redis.Cmder, error)); ok {
		return rf(fn)
	}
	if rf, ok := ret.Get(0).(func(func(redis.Pipeliner) error) []redis.Cmder); ok {
		r0 = rf(fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]redis.Cmder)
		}
	}

	if rf, ok := ret.Get(1).(func(func(redis.Pipeliner) error) error); ok {
		r1 = rf(fn)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Type provides a mock function with given fields: key
func (_m *Cmdable) Type(key string) *redis.StatusCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for Type")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string) *redis.StatusCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// Unlink provides a mock function with given fields: keys
func (_m *Cmdable) Unlink(keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Unlink")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.IntCmd); ok {
		r0 = rf(keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XAck provides a mock function with given fields: stream, group, ids
func (_m *Cmdable) XAck(stream string, group string, ids ...string) *redis.IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream, group)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XAck")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, ...string) *redis.IntCmd); ok {
		r0 = rf(stream, group, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XAdd provides a mock function with given fields: a
func (_m *Cmdable) XAdd(a *redis.XAddArgs) *redis.StringCmd {
	ret := _m.Called(a)

	if len(ret) == 0 {
		panic("no return value specified for XAdd")
	}

	var r0 *redis.StringCmd
	if rf, ok := ret.Get(0).(func(*redis.XAddArgs) *redis.StringCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringCmd)
		}
	}

	return r0
}

// XClaim provides a mock function with given fields: a
func (_m *Cmdable) XClaim(a *redis.XClaimArgs) *redis.XMessageSliceCmd {
	ret := _m.Called(a)

	if len(ret) == 0 {
		panic("no return value specified for XClaim")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(*redis.XClaimArgs) *redis.XMessageSliceCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XClaimJustID provides a mock function with given fields: a
func (_m *Cmdable) XClaimJustID(a *redis.XClaimArgs) *redis.StringSliceCmd {
	ret := _m.Called(a)

	if len(ret) == 0 {
		panic("no return value specified for XClaimJustID")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(*redis.XClaimArgs) *redis.StringSliceCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// XDel provides a mock function with given fields: stream, ids
func (_m *Cmdable) XDel(stream string, ids ...string) *redis.IntCmd {
	_va := make([]interface{}, len(ids))
	for _i := range ids {
		_va[_i] = ids[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, stream)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XDel")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...string) *redis.IntCmd); ok {
		r0 = rf(stream, ids...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupCreate provides a mock function with given fields: stream, group, start
func (_m *Cmdable) XGroupCreate(stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreate")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.StatusCmd); ok {
		r0 = rf(stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XGroupCreateMkStream provides a mock function with given fields: stream, group, start
func (_m *Cmdable) XGroupCreateMkStream(stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupCreateMkStream")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.StatusCmd); ok {
		r0 = rf(stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XGroupDelConsumer provides a mock function with given fields: stream, group, consumer
func (_m *Cmdable) XGroupDelConsumer(stream string, group string, consumer string) *redis.IntCmd {
	ret := _m.Called(stream, group, consumer)

	if len(ret) == 0 {
		panic("no return value specified for XGroupDelConsumer")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.IntCmd); ok {
		r0 = rf(stream, group, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupDestroy provides a mock function with given fields: stream, group
func (_m *Cmdable) XGroupDestroy(stream string, group string) *redis.IntCmd {
	ret := _m.Called(stream, group)

	if len(ret) == 0 {
		panic("no return value specified for XGroupDestroy")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.IntCmd); ok {
		r0 = rf(stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XGroupSetID provides a mock function with given fields: stream, group, start
func (_m *Cmdable) XGroupSetID(stream string, group string, start string) *redis.StatusCmd {
	ret := _m.Called(stream, group, start)

	if len(ret) == 0 {
		panic("no return value specified for XGroupSetID")
	}

	var r0 *redis.StatusCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.StatusCmd); ok {
		r0 = rf(stream, group, start)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StatusCmd)
		}
	}

	return r0
}

// XLen provides a mock function with given fields: stream
func (_m *Cmdable) XLen(stream string) *redis.IntCmd {
	ret := _m.Called(stream)

	if len(ret) == 0 {
		panic("no return value specified for XLen")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(stream)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XPending provides a mock function with given fields: stream, group
func (_m *Cmdable) XPending(stream string, group string) *redis.XPendingCmd {
	ret := _m.Called(stream, group)

	if len(ret) == 0 {
		panic("no return value specified for XPending")
	}

	var r0 *redis.XPendingCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.XPendingCmd); ok {
		r0 = rf(stream, group)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XPendingCmd)
		}
	}

	return r0
}

// XPendingExt provides a mock function with given fields: a
func (_m *Cmdable) XPendingExt(a *redis.XPendingExtArgs) *redis.XPendingExtCmd {
	ret := _m.Called(a)

	if len(ret) == 0 {
		panic("no return value specified for XPendingExt")
	}

	var r0 *redis.XPendingExtCmd
	if rf, ok := ret.Get(0).(func(*redis.XPendingExtArgs) *redis.XPendingExtCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XPendingExtCmd)
		}
	}

	return r0
}

// XRange provides a mock function with given fields: stream, start, stop
func (_m *Cmdable) XRange(stream string, start string, stop string) *redis.XMessageSliceCmd {
	ret := _m.Called(stream, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for XRange")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.XMessageSliceCmd); ok {
		r0 = rf(stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRangeN provides a mock function with given fields: stream, start, stop, count
func (_m *Cmdable) XRangeN(stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	ret := _m.Called(stream, start, stop, count)

	if len(ret) == 0 {
		panic("no return value specified for XRangeN")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(string, string, string, int64) *redis.XMessageSliceCmd); ok {
		r0 = rf(stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRead provides a mock function with given fields: a
func (_m *Cmdable) XRead(a *redis.XReadArgs) *redis.XStreamSliceCmd {
	ret := _m.Called(a)

	if len(ret) == 0 {
		panic("no return value specified for XRead")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(*redis.XReadArgs) *redis.XStreamSliceCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XReadGroup provides a mock function with given fields: a
func (_m *Cmdable) XReadGroup(a *redis.XReadGroupArgs) *redis.XStreamSliceCmd {
	ret := _m.Called(a)

	if len(ret) == 0 {
		panic("no return value specified for XReadGroup")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(*redis.XReadGroupArgs) *redis.XStreamSliceCmd); ok {
		r0 = rf(a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XReadStreams provides a mock function with given fields: streams
func (_m *Cmdable) XReadStreams(streams ...string) *redis.XStreamSliceCmd {
	_va := make([]interface{}, len(streams))
	for _i := range streams {
		_va[_i] = streams[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for XReadStreams")
	}

	var r0 *redis.XStreamSliceCmd
	if rf, ok := ret.Get(0).(func(...string) *redis.XStreamSliceCmd); ok {
		r0 = rf(streams...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XStreamSliceCmd)
		}
	}

	return r0
}

// XRevRange provides a mock function with given fields: stream, start, stop
func (_m *Cmdable) XRevRange(stream string, start string, stop string) *redis.XMessageSliceCmd {
	ret := _m.Called(stream, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for XRevRange")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.XMessageSliceCmd); ok {
		r0 = rf(stream, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XRevRangeN provides a mock function with given fields: stream, start, stop, count
func (_m *Cmdable) XRevRangeN(stream string, start string, stop string, count int64) *redis.XMessageSliceCmd {
	ret := _m.Called(stream, start, stop, count)

	if len(ret) == 0 {
		panic("no return value specified for XRevRangeN")
	}

	var r0 *redis.XMessageSliceCmd
	if rf, ok := ret.Get(0).(func(string, string, string, int64) *redis.XMessageSliceCmd); ok {
		r0 = rf(stream, start, stop, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.XMessageSliceCmd)
		}
	}

	return r0
}

// XTrim provides a mock function with given fields: key, maxLen
func (_m *Cmdable) XTrim(key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(key, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for XTrim")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.IntCmd); ok {
		r0 = rf(key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// XTrimApprox provides a mock function with given fields: key, maxLen
func (_m *Cmdable) XTrimApprox(key string, maxLen int64) *redis.IntCmd {
	ret := _m.Called(key, maxLen)

	if len(ret) == 0 {
		panic("no return value specified for XTrimApprox")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64) *redis.IntCmd); ok {
		r0 = rf(key, maxLen)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAdd provides a mock function with given fields: key, members
func (_m *Cmdable) ZAdd(key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAdd")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddCh provides a mock function with given fields: key, members
func (_m *Cmdable) ZAddCh(key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddCh")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddNX provides a mock function with given fields: key, members
func (_m *Cmdable) ZAddNX(key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddNX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddNXCh provides a mock function with given fields: key, members
func (_m *Cmdable) ZAddNXCh(key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddNXCh")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddXX provides a mock function with given fields: key, members
func (_m *Cmdable) ZAddXX(key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddXX")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZAddXXCh provides a mock function with given fields: key, members
func (_m *Cmdable) ZAddXXCh(key string, members ...redis.Z) *redis.IntCmd {
	_va := make([]interface{}, len(members))
	for _i := range members {
		_va[_i] = members[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZAddXXCh")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...redis.Z) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZCard provides a mock function with given fields: key
func (_m *Cmdable) ZCard(key string) *redis.IntCmd {
	ret := _m.Called(key)

	if len(ret) == 0 {
		panic("no return value specified for ZCard")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string) *redis.IntCmd); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZCount provides a mock function with given fields: key, min, max
func (_m *Cmdable) ZCount(key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.IntCmd); ok {
		r0 = rf(key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZIncr provides a mock function with given fields: key, member
func (_m *Cmdable) ZIncr(key string, member redis.Z) *redis.FloatCmd {
	ret := _m.Called(key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncr")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, redis.Z) *redis.FloatCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZIncrBy provides a mock function with given fields: key, increment, member
func (_m *Cmdable) ZIncrBy(key string, increment float64, member string) *redis.FloatCmd {
	ret := _m.Called(key, increment, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrBy")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, float64, string) *redis.FloatCmd); ok {
		r0 = rf(key, increment, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZIncrNX provides a mock function with given fields: key, member
func (_m *Cmdable) ZIncrNX(key string, member redis.Z) *redis.FloatCmd {
	ret := _m.Called(key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrNX")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, redis.Z) *redis.FloatCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZIncrXX provides a mock function with given fields: key, member
func (_m *Cmdable) ZIncrXX(key string, member redis.Z) *redis.FloatCmd {
	ret := _m.Called(key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZIncrXX")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, redis.Z) *redis.FloatCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZInterStore provides a mock function with given fields: destination, store, keys
func (_m *Cmdable) ZInterStore(destination string, store redis.ZStore, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, destination, store)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZInterStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, redis.ZStore, ...string) *redis.IntCmd); ok {
		r0 = rf(destination, store, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZLexCount provides a mock function with given fields: key, min, max
func (_m *Cmdable) ZLexCount(key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZLexCount")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.IntCmd); ok {
		r0 = rf(key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZPopMax provides a mock function with given fields: key, count
func (_m *Cmdable) ZPopMax(key string, count ...int64) *redis.ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZPopMax")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, ...int64) *redis.ZSliceCmd); ok {
		r0 = rf(key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZPopMin provides a mock function with given fields: key, count
func (_m *Cmdable) ZPopMin(key string, count ...int64) *redis.ZSliceCmd {
	_va := make([]interface{}, len(count))
	for _i := range count {
		_va[_i] = count[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZPopMin")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, ...int64) *redis.ZSliceCmd); ok {
		r0 = rf(key, count...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRange provides a mock function with given fields: key, start, stop
func (_m *Cmdable) ZRange(key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeByLex provides a mock function with given fields: key, opt
func (_m *Cmdable) ZRangeByLex(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByLex")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeByScore provides a mock function with given fields: key, opt
func (_m *Cmdable) ZRangeByScore(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByScore")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRangeByScoreWithScores provides a mock function with given fields: key, opt
func (_m *Cmdable) ZRangeByScoreWithScores(key string, opt redis.ZRangeBy) *redis.ZSliceCmd {
	ret := _m.Called(key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeByScoreWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, redis.ZRangeBy) *redis.ZSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRangeWithScores provides a mock function with given fields: key, start, stop
func (_m *Cmdable) ZRangeWithScores(key string, start int64, stop int64) *redis.ZSliceCmd {
	ret := _m.Called(key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRangeWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.ZSliceCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRank provides a mock function with given fields: key, member
func (_m *Cmdable) ZRank(key string, member string) *redis.IntCmd {
	ret := _m.Called(key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.IntCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRem provides a mock function with given fields: key, members
func (_m *Cmdable) ZRem(key string, members ...interface{}) *redis.IntCmd {
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, members...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZRem")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *redis.IntCmd); ok {
		r0 = rf(key, members...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByLex provides a mock function with given fields: key, min, max
func (_m *Cmdable) ZRemRangeByLex(key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByLex")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.IntCmd); ok {
		r0 = rf(key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByRank provides a mock function with given fields: key, start, stop
func (_m *Cmdable) ZRemRangeByRank(key string, start int64, stop int64) *redis.IntCmd {
	ret := _m.Called(key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.IntCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRemRangeByScore provides a mock function with given fields: key, min, max
func (_m *Cmdable) ZRemRangeByScore(key string, min string, max string) *redis.IntCmd {
	ret := _m.Called(key, min, max)

	if len(ret) == 0 {
		panic("no return value specified for ZRemRangeByScore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string, string) *redis.IntCmd); ok {
		r0 = rf(key, min, max)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZRevRange provides a mock function with given fields: key, start, stop
func (_m *Cmdable) ZRevRange(key string, start int64, stop int64) *redis.StringSliceCmd {
	ret := _m.Called(key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRange")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.StringSliceCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByLex provides a mock function with given fields: key, opt
func (_m *Cmdable) ZRevRangeByLex(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByLex")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByScore provides a mock function with given fields: key, opt
func (_m *Cmdable) ZRevRangeByScore(key string, opt redis.ZRangeBy) *redis.StringSliceCmd {
	ret := _m.Called(key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByScore")
	}

	var r0 *redis.StringSliceCmd
	if rf, ok := ret.Get(0).(func(string, redis.ZRangeBy) *redis.StringSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.StringSliceCmd)
		}
	}

	return r0
}

// ZRevRangeByScoreWithScores provides a mock function with given fields: key, opt
func (_m *Cmdable) ZRevRangeByScoreWithScores(key string, opt redis.ZRangeBy) *redis.ZSliceCmd {
	ret := _m.Called(key, opt)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeByScoreWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, redis.ZRangeBy) *redis.ZSliceCmd); ok {
		r0 = rf(key, opt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRevRangeWithScores provides a mock function with given fields: key, start, stop
func (_m *Cmdable) ZRevRangeWithScores(key string, start int64, stop int64) *redis.ZSliceCmd {
	ret := _m.Called(key, start, stop)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRangeWithScores")
	}

	var r0 *redis.ZSliceCmd
	if rf, ok := ret.Get(0).(func(string, int64, int64) *redis.ZSliceCmd); ok {
		r0 = rf(key, start, stop)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ZSliceCmd)
		}
	}

	return r0
}

// ZRevRank provides a mock function with given fields: key, member
func (_m *Cmdable) ZRevRank(key string, member string) *redis.IntCmd {
	ret := _m.Called(key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZRevRank")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.IntCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// ZScan provides a mock function with given fields: key, cursor, match, count
func (_m *Cmdable) ZScan(key string, cursor uint64, match string, count int64) *redis.ScanCmd {
	ret := _m.Called(key, cursor, match, count)

	if len(ret) == 0 {
		panic("no return value specified for ZScan")
	}

	var r0 *redis.ScanCmd
	if rf, ok := ret.Get(0).(func(string, uint64, string, int64) *redis.ScanCmd); ok {
		r0 = rf(key, cursor, match, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.ScanCmd)
		}
	}

	return r0
}

// ZScore provides a mock function with given fields: key, member
func (_m *Cmdable) ZScore(key string, member string) *redis.FloatCmd {
	ret := _m.Called(key, member)

	if len(ret) == 0 {
		panic("no return value specified for ZScore")
	}

	var r0 *redis.FloatCmd
	if rf, ok := ret.Get(0).(func(string, string) *redis.FloatCmd); ok {
		r0 = rf(key, member)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.FloatCmd)
		}
	}

	return r0
}

// ZUnionStore provides a mock function with given fields: dest, store, keys
func (_m *Cmdable) ZUnionStore(dest string, store redis.ZStore, keys ...string) *redis.IntCmd {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, dest, store)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ZUnionStore")
	}

	var r0 *redis.IntCmd
	if rf, ok := ret.Get(0).(func(string, redis.ZStore, ...string) *redis.IntCmd); ok {
		r0 = rf(dest, store, keys...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*redis.IntCmd)
		}
	}

	return r0
}

// NewCmdable creates a new instance of Cmdable. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCmdable(t interface {
	mock.TestingT
	Cleanup(func())
}) *Cmdable {
	mock := &Cmdable{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
